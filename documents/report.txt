Customer -> overloaded constructor so that the customer name can be left blank if the customer does not want to give their name

UML Diagram
The projection is the intersection between a film and a screen. 
There are 50 seats in each screen, ten of which are VIP seats. The UML diagram makes this flexible to allow for possible future change. It also allows for the seats to be made unavailable, if for example it was broken or dirty. 
The system creates a seat grid based on the seating table, and the seat-unavailable and vip-seat information. This grid is used to construct the interface where customers select the seats. 

Upgrade policy
Customers can change their booking. They can choose to be upgraded to a VIP seat, or to a more expensive screening. These upgrades are at a cost. The customer must pay the extra amount. 
If a customer chooses to downgrade to a cheaper screening, or to a non-VIP seat, they can not receive a refund. However, the downgrade can take place. 

The objects are stored in HashMaps. The hashmap is stored in the cinema class. If the system was to cater for multiple cinema instances, some of these hashmaps would be located in their classes. For example, the same film will be shown in multiple cinemas, so if the system was to cater for multiple cinemas then the collection of films is stored in the film class to allow the user to compare films across multiple cinemas. 

Film stores subtitles as empty string if there are no subtitles. The constructor and methods are overloaded if there are no subtitles for the film. 

The rating is stored in the seat-assignment. Since bookings can be for more than one ticket, each ticket is allowed to leave one review. 

Projections -> before a projection is created, it must first be validated to ensure that the film and the screen are available. This is carried out by the isValidProjection method. This validation process will still work if there are multiple copies of the film. Each copy of the film is assigned to a separate object. Since the method checks whether the objects are equal, rather than whether the titles of the films are equal, the method will work correctly for multiple copies of the same film. 

Booker -> the booker object manages the seat reservations. It adds temporary seat-reservations to the projection seating grid. A seatReservationList is stored, and the boolean[][] grid is updated with the temporary seat reservations. Once all seats have been selected, the Booker confirms the purchase can commits the temporary seat reservations to the database. 


Changing a booking -> if a booking is for multiple tickets, then it is possible that some of the tickets will need to be changed for different projections. In order to allow this, the projection is not directly linked to the booking. The projection is linked to the ticket, and the booking is a collection of tickets.

The List of tickets is stored in the projection class, rather than the booking class. All the reporting is drawn from the relationship between the ticket objects and their projections.  

Customer: consider removing the customer class, or making it optional. Cinema's don't need your name in order to sell you a ticket. 

Autoincrementing the IDs -> while it is more intuitive to allow the objects to autoincrement their own ids by storing seperate (int NEXT_ID) values in each object-class, it was decided to store this functionality centrally in the Cinema class. The system will at some point need to use a persistent database, which will have its own autoincrementing feature. By storing the autoincrement centrally now, it will make it easier in the future to migrate the system to incorporate a database, and then use the autoincremented id from that database as the id numbers for the system. 

Booker -> when a new booking starts, call cinema.getNewBooker(). This clears the last booker, so that there cannot be conflict between the seatReservation list if a booking is abandoned. 

Payment -> Customers can switch their ticket for another projection or another seat. I decided that the cinema does not offer refunds if the new seat is cheaper than the old one. However, the customer does need to pay the difference if the price of the old ticket is lower than the new ticket. Therefore, each booking can have more than one payment. 

CLI -> When a booking is made, the user will enter the customer id. Customers carry ODEON cards with an id number. Unfortunately, some customers tend to forget to bring their card, so there needs to be a way to retrieve this id number. The user can view an index of all customers in the database, ordered by the customer's name. It only shows the customers whose names we know. If there is no name, then the customer has not given their name, and they are therefore not a member. 

CLI -> when booking a new ticket, take the customer id. If they are a new customer, create a new customer. 

Projection was renamed to Show because it is a term that will be easier for the end-user to understand. 

CLI -> whatever input the user gives, the application will do something. If the integer entered is out of range (for example, in filmsShow), the application will reload the current page, rather than showing an error notification and quitting. 
